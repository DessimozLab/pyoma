if not assigned(root_dir) then
    exit(1);
fi:
libdir := root_dir.'/lib/';
ReadProgram(root_dir.'/lib/darwinit');
ReadProgram(root_dir.'/parameters.drw');
G := TimedCallSystem('find -L '.root_dir.'/DB -name "*.fa" -print')[2];
G := sort(SearchDelim('\n',G));
_next_new_taxid := -100;
genomes := []: DBs := table(): GS := table(): TaxonIDs := table():
for g in G do
    off := SearchAllString('/', g);
    gname := g[off[-1]+1..-1];
    off := SearchString('.',gname);
    gname := gname[1..off];
    genomes := append(genomes, gname):
    DB := ReadDb(root_dir.'/Cache/DB/'.gname.'.db');
    GS[gname] := GenomeSummary(DB):
    DBs[gname] := DB;
    tax := SearchTag('TAXONID', DB['string']);
    if tax='' then
        TaxonIDs[gname] := _next_new_taxid; _next_new_taxid := _next_new_taxid - 1;
    else
        TaxonIDs[gname] := tax;
    fi:
od:
NS := length(genomes);
Goff := CreateArray(1..NS+1):
for i to NS do Goff[i+1] := Goff[i]+GS[genomes[i],TotEntries] od:
SubGenome := table(0);



# code from PhylogeneticTree (LINEAGE) augmented to store the internal
# node names.
SpeciesTreeR := proc( l, lev, parent )
    global _parents;
#    print('',l);
#    lprint(lev,parent, length(l), min( seq(length(r[1]), r=l )));
    if length(l)=0 then error('null tree')
    elif length(l)=1 then
        tax := parse(GS[l[1,2],TAXONID]);
        _parents := append(_parents, [tax, parent, GS[l[1,2],'SCINAME']]);
        #Leaf(l[1,2],length(l[1,1])+1)
    elif lev > min( seq(length(r[1]), r=l )) then
        tax := parse(GS[l[1,2], TAXONID]);
        if tax<>parent then
            _parents := append(_parents,
                [tax, parent, TaxonomyEntry(tax)['SciName']]);
        else
            warning('tax '.string(tax).' is already recorded.');
        fi:
        procname(l[2..-1], lev, parent);
        #Tree( Leaf(l[1,2],length(l[1,1])+1), lev, procname( l[2..-1], lev ))
    else
        card := { seq( r[1,lev], r=l ) };
        tax := getTaxid(l[1,1,lev]);
        _parents := append(_parents, [tax, parent, l[1,1,lev]]);
        if length(card)=1 then
            return( procname(l, lev+1, tax) );
        fi;
        for hi from 2 while l[1,1,lev] = l[hi,1,lev] do od;
        procname( l[1..hi-1], lev+1, tax );
        procname( l[hi..-1], lev, parent );
    fi:
end:

TreeToParentTable := proc(tree, parent; (h0=0):numeric)
    global _parents, _next_new_taxid;
    if length(tree)=0 then error('null tree');
    elif type(tree, Leaf) then
        sciname := GS[tree['Label'], SCINAME];
        if sciname = '' then sciname := tree['Label'] fi:
        _parents := append(_parents, [TaxonIDs[tree['Label']], parent, sciname]);
        return({tree['Label']});
    else
        branchlength := |tree['Height'] - h0|;
        next_parent := parent;
        if branchlength > 1e-4 then
            next_parent := _next_new_taxid;
            _next_new_taxid := _next_new_taxid - 1;
        fi:
        tL := procname(tree['Left'], next_parent, tree['Height']);
        tR := procname(tree['Right'], next_parent, tree['Height']);
        covered := union(tL, tR);
        lev := ConcatStrings([op(covered)], '/');
        if next_parent<>parent then
            _parents := append(_parents, [next_parent, parent, lev]);
        fi:
        return(covered);
    fi:
end:


getTaxid := proc(lin)
    global _next_new_taxid;
    tax := traperror(TaxonomyEntry(lin)['id']);
    if tax=lasterror then
        tax := _next_new_taxid;
        _next_new_taxid := _next_new_taxid-1;
    fi:
    return(tax);
end:

GetGenomeData := proc()
    global _parents;
    gs := [];
    for gNr to NS do
        g := genomes[gNr];
        sciname := GS[g,SCINAME];
        if sciname='' then sciname := g fi:
        gs := append(gs, [TaxonIDs[g], GS[g, '5LETTERNAME'], GS[g,TotEntries],
            GS[g,TotAA], Goff[gNr], sciname, GS[g,DBRELEASE],
            SubGenome[g]<>0]);
    od:

    tab := table():
    tab['GS'] := gs:
    _parents := []:
    if lower(SpeciesTree)='lineage' then
        linData := sort([seq([GS[g,Lineage], g], g=genomes)]):
        SpeciesTreeR(linData, 1, 0);
    else
        stree := SpeciesTree;
        if lowercase(SpeciesTree)='estimate' then
            stree := ReadRawFile(root_dir.'/'.OutputFolder.'/EstimatedSpeciesTree.nwk');
        fi:
        TreeToParentTable(ParseNewickTree(stree), 0):
        _parents := append(_parents, [0,0,'LUCA']);
    fi:
    tab['Tax'] := _parents:
    StoreResults(json(tab));
end:

RefinedMatches := proc(ms)
    global Homologs, Orthologs;

end:

TransformDataToCache := proc(cache_dir)
    global VPairs, Paralogs, StablePairs, Ort, VPs, rev;

    ReadProgram(root_dir.'/Cache/ortholog_milestone.drw.gz');
    Prot2Grp := CreateArray(1..Goff[NS+1]):
    for og to length(Ort) do for gNr to NS do if Ort[og,gNr]<>0 then
        Prot2Grp[Goff[gNr]+Ort[og,gNr]] := og;
    fi od od:
    CallSystem('mkdir -p '.cache_dir.'/{vps,prots,homologs}');
    for g in genomes do
        StoreProteinsForGenome(g, Prot2Grp, cache_dir.'/vps/'.GS[g,'5LETTERNAME'].'.json');
    od:

    for X to NS do for Y to NS do
        if GS[genomes[X],TotEntries] < GS[genomes[Y],TotEntries] or
           GS[genomes[X],TotEntries] = GS[genomes[Y],TotEntries] and genomes[X]<genomes[Y] then
            g1 := genomes[X], g2 := genomes[Y]; off1 = Goff[X]; off2 := Goff[Y]; VPs := VPairs[X,Y]: rev := false;
        else
            g1 := genomes[Y], g2 := genomes[X]; off1 = Goff[Y]; off2 := Goff[X]; VPs := VPairs[Y,X]: rev := true;
        fi:
    od od:

end:

GetVPsForGenome := proc(g)
    global DB;
    ReadDb(ddir.'/ServerVPs.db');
    gNr := SearchArray(g,genomes);
    vptab := []:
    for i from Goff[gNr]+1 to Goff[gNr+1] do
        for vp in parse(SearchTag('VP',Entry(i))) do
            vptab := append(vptab, [i, vp, 'n/a'])
        od:
    od:
    StoreResults(json(vptab)):
end:

GetSameSpeciesRelations := proc(g)
    global DB;
    ReadDb(ddir.'/ServerVPs.db');
    gNr := SearchArray(g, genomes);
    ssTab :=  []:
    for i from Goff[gNr]+1 to Goff[gNr+1] do
        e := Entry(i);
        for cp in parse(SearchTag('CP', e)) do
            ssTab := append(ssTab, [i, cp, 'close paralog', -1, -1, -1, -1]);
        od:
        hpTag := SearchTag('HP', e);
        if hpTag<>'' then for hp in parse(hpTag) do
            ssTab := append(ssTab, [i, hp[1], 'homeolog', -1, hp[2], -1, -1, -1]);
        od fi:
    od:
    StoreResults(json(ssTab));
end:

StoreProteinsForGenome := proc(g, grps, fname)
    global DB, Splicings;
    tab:= table():
    gNr := SearchArray(g, genomes);
    DB := DBs[g];
    tab['seqs'] := [seq(Sequence(Entry(i)),i=1..GS[g,TotEntries])]:
    tab['cdna'] := [seq(CreateString(length(z)*3, 'X'), z=tab['seqs'])]:
    tab['off'] := Goff[gNr]:
    tab['ogs'] := grps[Goff[gNr]+1..Goff[gNr+1]];
    tab['chrs'] := [seq(SearchTag('CHR',Entry(i)), i=1..GS[g,TotEntries])];
    tab['locs'] := [seq(SearchTag('LOC',Entry(i)), i=1..GS[g,TotEntries])];
    if SubGenome[g]<>0 then
        tab['subgenome'] := [seq(SubGenome[g,i], i=1..GS[g,TotEntries])]
    else
        tab['subgenome'] := [seq('', GS[g,TotEntries])]
    fi:
    sp := Splicings[g]:
    alt := CreateArray(1..GS[g,TotEntries]):
    if sp<>0 then
        VPsDB := ReadDb(ddir.'/ServerVPs.db');
        hasO := [seq(evalb(SearchTag('VP',Entry(Goff[gNr]+i))<>'[]'),
                     i=1..GS[g,TotEntries])]:
        for i to GS[g,TotEntries] do
            if alt[i]=0 and length(sp[i])>0 then
                vari := [op({op(sp[i]),i})];
                varHasO := [seq(hasO[i],i=vari)];
                main := SearchAllArray(true, varHasO);
                if length(main)=0 then
                    main := vari[1]+Goff[gNr];
                else
                    if length(main)>1 then
                        warning('more than one main variant for '.g.string(vari));
                    fi:
                    main := vari[main[1]]+Goff[gNr];
                fi;
                for k to length(vari) do
                    alt[vari[k]] := main;
                od:
            fi:
        od:
    fi:

    tab['alts'] := alt;
    StoreResults(json(tab), fname):
end:



StoreResults := proc(res, fname)
    if nargs = 1 then
        return(procname(args, outfn))
    fi:
    OpenWriting(fname);
    prints(res);
    OpenWriting(previous);
end:

